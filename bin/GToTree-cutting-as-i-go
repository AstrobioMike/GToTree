

#############################################################################
###########################  SOME LAST ADJUSTMENTS  #########################
#############################################################################

# starting an all genomes file to keep track of those from all sources
touch ${tmp_dir}/genomes_from_all_sources.tmp

# starting the SCG-counts per genome tab which will have the following as its header:
paste <(printf "assembly_id") <(printf %s "$(cat ${tmp_dir}/uniq_hmm_names.tmp | tr "\n" "\t" | sed 's/.$//')") > ${output_dir}/SCG_hit_counts.tsv

#############################################################################
########################  KEEPING TRACK OF RUN TIME  ########################
#############################################################################
start_time=$(date +"%I:%M %p")
SECONDS=0


#############################################################################
######  GETTING AND BUILDING NEEDED KO STUFF IF USER WANTS KO SCANNING  #####
#############################################################################
if [ "$ko_targets" != 'false' ]; then

    printf "\n ############################################################################## \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    printf " ####                     Setting up HMMs for KO targets                   ####\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    printf " ############################################################################## \n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

    # making output dirs
    mkdir -p ${output_dir}/KO_search_results/target_KO_profiles/
    mkdir -p ${output_dir}/KO_search_results/KO_hit_seqs/
    mkdir -p ${output_dir}/KO_search_results/iToL_files/
    mkdir -p ${output_dir}/KO_search_results/individual_genome_results/

    gtt-parse-kofamscan-targets.sh ${target_KOs} ${output_dir}

fi


#############################################################################
##########  GETTING AND BUILDING ADDITIONAL TARGET PFAM HMM IF SET  #########
#############################################################################
if [ "$additional_pfam_targets" != 'false' ]; then

    printf "\n ############################################################################## \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    printf " ####              Downloading HMMs for additional Pfam targets            ####\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    printf " ############################################################################## \n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

    # making output dirs
    mkdir -p ${output_dir}/Pfam_search_results/target_Pfam_profiles/
    mkdir -p ${output_dir}/Pfam_search_results/Pfam_hit_seqs/
    mkdir -p ${output_dir}/Pfam_search_results/iToL_files/
    mkdir -p ${output_dir}/Pfam_search_results/individual_genome_results/
    mkdir -p ${output_dir}/Pfam_search_results/info/

    gtt-get-additional-pfam-targets.sh ${tmp_dir} ${output_dir}

fi


#############################################################################
#############  ALIGNING, TRIMMING, AND INSERTING GAP-SEQUENCES  #############
#############################################################################
printf "\n ############################################################################## \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
printf " ####          Aligning, trimming, and inserting gap-sequences             ####\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
printf " ############################################################################## \n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

curr_time=$(date +"%I:%M %p")
duration=$SECONDS

printf "           It is currently $curr_time; the process started at $start_time.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
printf "               Current process runtime: $(($duration / 60 / 60)) hours and $((($duration / 60) % 60)) minutes.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )


### running in parallel if set, otherwise running in serial ###
if [ $num_jobs == "1" ]; then

    # setting new counter
    num=0

    for SCG in $(cat ${tmp_dir}/final_genes_list.tmp)

    do

        num=$((num+1))

        printf "\n\n\n   --------------------------------------------------------------------------   \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "\t    Aligning and cleaning gene ${GREEN}$SCG${NC}; Number $num of $new_hmm_target_genes_total.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "   --------------------------------------------------------------------------   \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

        # removing those genomes that need to be removed based on not having enough hits to the target genes
        gtt-parse-fasta-by-headers -i ${tmp_dir}/${SCG}_hits_filtered.tmp -w ${tmp_dir}/sorted_genomes_to_remove.tmp -o ${tmp_dir}/${SCG}_hits_filtered${target_gene_suffix} --inverse

        # aligning
        if [ $total_input_genomes -ge 1000 ] && [ $override_faster_alignment == 'false' ]; then
            muscle -super5 ${tmp_dir}/${SCG}_hits_filtered${target_gene_suffix} -output ${tmp_dir}/${SCG}-aligned.tmp -threads ${num_muscle_threads} | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        else
            muscle -align ${tmp_dir}/${SCG}_hits_filtered${target_gene_suffix} -output ${tmp_dir}/${SCG}-aligned.tmp -threads ${num_muscle_threads} | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        fi

        # checking if alignment was successful (really this is a sloppy way of checking, but it's better than nothing and the muscle logs will be in the stdout and log)
        if [ ! -s ${tmp_dir}/${SCG}-aligned.tmp ]; then

            printf "\n\n ${RED}############################################################################## \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf " ${RED}############################################################################## \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf " ####${NC}             GToTree is exiting without completing :(                 ${RED}####\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf " ##############################################################################${NC} \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf " ${RED}############################################################################## \n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

            printf "  ${RED}************************** ${NC}REASON FOR TERMINATION ${RED}**************************${NC}  \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf "    There was a problem with muscle generating an alignment, so GToTree is exiting. This\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf "    is most often due to running out of memory, leading to a 'core dumped' message from muscle.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf "    You can check the muscle log output printed above, specifically look for ${SCG}.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf "    If you can't access more memory, it would help to reduce the number of included\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf "    genomes if possible." | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf "  ${RED}**************************************************************************** ${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

            printf "\nExiting for now.\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

            # removing tmp directory unless debug set
            if [ $debug_flag == 'false' ]; then
                rm -rf $tmp_dir
            fi

            mv $gtotree_log ${output_dir}/gtotree-runlog.txt
            exit

        fi

        # trimming
        trimal -in ${tmp_dir}/${SCG}-aligned.tmp -out ${tmp_dir}/trimmed${target_gene_suffix}.tmp -automated1

        # removing linewraps:
        sed 's/ .*$//' ${tmp_dir}/trimmed${target_gene_suffix}.tmp | awk '!/^>/ { printf "%s", $0; n="\n" } /^>/ { print n $0; n = "" } END { printf "%s", n }' > ${tmp_dir}/formatted${target_gene_suffix}.tmp

        ## adding gap-sequences for genomes missing the current gene ##
        # finding here which ones have it
        grep ">" ${tmp_dir}/formatted${target_gene_suffix}.tmp | tr -d ">" | sort > ${tmp_dir}/genomes_with_gene.tmp

        # now getting which ones don't have it
        comm -23 ${tmp_dir}/final_genomes_from_all_sources.tmp ${tmp_dir}/genomes_with_gene.tmp | sort > ${tmp_dir}/needed_gappers.tmp

        # creating gap-sequences if needed
        if [ -s ${tmp_dir}/needed_gappers.tmp ]; then

            # making a headers file for when making fasta in a few steps:
            sed 's/^/>/' ${tmp_dir}/needed_gappers.tmp > ${tmp_dir}/needed_headers.tmp

            # getting length of the alignment for the current gene:
            aln_length_tmp=$(sed -n '2p' ${tmp_dir}/formatted${target_gene_suffix}.tmp | wc -c | tr -s " " | cut -f2 -d " ")
            # subtracting 1 for newline characters
            aln_length_tmp=$(echo "$aln_length_tmp"-1 | bc)
            # making a string of gaps the length of the alignment for those missing it:
            gap_seq=$(printf "%0.s-" $(seq 1 1 $aln_length_tmp))
            # making as many gap sequences as there are genomes missing the current gene:
            num_genomes_to_add=$(wc -l ${tmp_dir}/needed_gappers.tmp | tr -s " " "\t" | cut -f2)
            for i in $(cat ${tmp_dir}/needed_gappers.tmp)
            do
                echo "$gap_seq"
            done > ${tmp_dir}/gaps.tmp

            # making fasta of those genomes missing the current gene:
            paste -d "\n" ${tmp_dir}/needed_headers.tmp ${tmp_dir}/gaps.tmp > ${tmp_dir}/missing_genomes${target_gene_suffix}.tmp
            # catting the genomes missing the current gene together with those that have it
            cat ${tmp_dir}/formatted${target_gene_suffix}.tmp ${tmp_dir}/missing_genomes${target_gene_suffix}.tmp > ${tmp_dir}/${SCG}${target_gene_suffix}.tmp
        else
            mv ${tmp_dir}/formatted${target_gene_suffix}.tmp ${tmp_dir}/${SCG}${target_gene_suffix}.tmp
        fi

        ## reordering the final fasta of this gene so that all gene sets can be pasted together at end ##
        gtt-reorder-fasta -i ${tmp_dir}/${SCG}${target_gene_suffix}.tmp -w ${tmp_dir}/final_genomes_from_all_sources.tmp -o ${tmp_dir}/${SCG}_all_aligned${target_gene_suffix}

    done

else

    # running in parallel
    if [ $total_input_genomes -ge 1000 ] && [ $override_faster_alignment == 'false' ]; then
        faster_alignment='true'
    else
        faster_alignment='false'
    fi

    cat ${tmp_dir}/final_genes_list.tmp | parallel -j $num_jobs gtt-align-and-trim-parallel.sh {} $tmp_dir $faster_alignment $num_muscle_threads $target_gene_suffix

    ### kill backstop ###
    # if there was a problem with the alignments, killing main program here and reporting

    if [ -f ${tmp_dir}/kill_align_and_trim_parallel.problem ]; then

        problem_alignment=$(head -n 1 ${tmp_dir}/kill_align_and_trim_parallel.problem)

        printf "\n\n ${RED}############################################################################## \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf " ${RED}############################################################################## \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf " ####${NC}             GToTree is exiting without completing :(                 ${RED}####\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf " ##############################################################################${NC} \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf " ${RED}############################################################################## \n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

        printf "  ${RED}************************** ${NC}REASON FOR TERMINATION ${RED}**************************${NC}  \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "    There was a problem with muscle generating an alignment, so GToTree is exiting. This\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "    is most often due to running out of memory, leading to a 'core dumped' message from muscle.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "    You can check the muscle log output in one of the problem sets by looking at:\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "    ${problem_alignment}-muscle.log. If you can't access more memory, it would help to\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "    reduce the number of included genomes if possible." | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "  ${RED}**************************************************************************** ${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

        printf "\nExiting for now.\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

        # copying muscle log file to primary working directory
        cp ${tmp_dir}/${problem_alignment}-muscle.log .

        # removing tmp directory unless debug set
        if [ $debug_flag == 'false' ]; then
            rm -rf $tmp_dir
        fi

        mv $gtotree_log ${output_dir}/gtotree-runlog.txt
        exit

    fi

fi

printf "\n\n\n________________________________________________________________________________\n\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )


#############################################################################
######################  MAKING SUMMARY TABLE WITH ALL  ######################
#############################################################################
if [ -f ${output_dir}/NCBI_genomes_summary_info.tsv ]; then
    cut -f 1,4,9,10,11,12 ${output_dir}/NCBI_genomes_summary_info.tsv | tail -n +2 >> ${tmp_dir}/building_genomes_tab.tmp
fi

if [ -f ${output_dir}/Genbank_genomes_summary_info.tsv ]; then
    cut -f 1,3,6,7,8,9 ${output_dir}/Genbank_genomes_summary_info.tsv | tail -n +2 >> ${tmp_dir}/building_genomes_tab.tmp
fi

if [ -f ${output_dir}/Fasta_genomes_summary_info.tsv ]; then
    cut -f 1,3,4,5,6,7 ${output_dir}/Fasta_genomes_summary_info.tsv | tail -n +2 >> ${tmp_dir}/building_genomes_tab.tmp
fi

if [ -f ${output_dir}/Amino_acid_genomes_summary_info.tsv ]; then
    cut -f 1,3,4,5,6,7 ${output_dir}/Amino_acid_genomes_summary_info.tsv | tail -n +2 >> ${tmp_dir}/building_genomes_tab.tmp
fi

## getting current ordered list of all genomes together:
cut -f 1 ${tmp_dir}/building_genomes_tab.tmp | sort > ${tmp_dir}/sorted_all_output_genome_ids.tmp

## adding columns stating whether genome made it into the final tree, how many SCG-hits they had after length filtering, and how many genes they contributed to final alignment if they weren't removed
# first getting which were removed from analysis due to too few hits, if any:
if [ $removed_genomes != "0" ]; then
    sort <(tail -n +2 ${output_dir}/Genomes_removed_for_too_few_hits.tsv | cut -f1) > ${tmp_dir}/sorted_genomes_removed_for_too_few_hits.tmp

    # getting a list of those that weren't removed to iterate over
    comm -23 ${tmp_dir}/sorted_all_output_genome_ids.tmp ${tmp_dir}/sorted_genomes_removed_for_too_few_hits.tmp | sort > ${tmp_dir}/sorted_genomes_not_removed.tmp

    ## getting table of those that were removed
    for genome in $(cat ${tmp_dir}/sorted_genomes_removed_for_too_few_hits.tmp)
    do
        grep -m1 -w "^$genome" ${tmp_dir}/building_genomes_tab.tmp >> ${tmp_dir}/building_genomes_tab_for_removed_genomes.tmp
        grep -m1 -w "^$genome" ${tmp_dir}/counts_tab.tmp | cut -f 2 >> ${tmp_dir}/reporting_SCG_counts_after_len_filt_for_genomes_removed.tmp
        echo "No" >> ${tmp_dir}/reporting_that_not_in_final_tree_column.tmp
    done

    # adding columns on:
    paste ${tmp_dir}/building_genomes_tab_for_removed_genomes.tmp ${tmp_dir}/reporting_SCG_counts_after_len_filt_for_genomes_removed.tmp ${tmp_dir}/reporting_that_not_in_final_tree_column.tmp > ${tmp_dir}/genomes_tab_for_removed_genomes.tmp

    ## getting table of those that weren't removed
    for genome in $(cat ${tmp_dir}/sorted_genomes_not_removed.tmp)
    do
        grep -m1 -w "^$genome" ${tmp_dir}/building_genomes_tab.tmp >> ${tmp_dir}/building_genomes_tab_for_retained_genomes.tmp
        grep -m1 -w "^$genome" ${tmp_dir}/counts_tab.tmp | cut -f 2 >> ${tmp_dir}/reporting_SCG_counts_after_len_filt_for_genomes_retained.tmp
        echo "Yes" >> ${tmp_dir}/reporting_that_in_final_tree_column.tmp
    done

    # adding columns on:
    paste ${tmp_dir}/building_genomes_tab_for_retained_genomes.tmp ${tmp_dir}/reporting_SCG_counts_after_len_filt_for_genomes_retained.tmp ${tmp_dir}/reporting_that_in_final_tree_column.tmp > ${tmp_dir}/genomes_tab_for_retained_genomes.tmp


    ## combining both together
    cat ${tmp_dir}/genomes_tab_for_retained_genomes.tmp ${tmp_dir}/genomes_tab_for_removed_genomes.tmp > ${tmp_dir}/building_genomes_tab.tmp

else
    # if there are no genomes to remove, then generating two new columns for all
    for genome in $(cat ${tmp_dir}/sorted_all_output_genome_ids.tmp)
    do
        grep -m1 -w "^$genome" ${tmp_dir}/building_genomes_tab.tmp >> ${tmp_dir}/building_genomes_tab_for_retained_genomes.tmp
        grep -m1 -w "^$genome" ${tmp_dir}/counts_tab.tmp | cut -f 2 >> ${tmp_dir}/reporting_SCG_counts_after_len_filt_for_genomes_retained.tmp
        echo "Yes" >> ${tmp_dir}/reporting_that_in_final_tree_column.tmp
    done

    # adding columns on:
    paste ${tmp_dir}/building_genomes_tab_for_retained_genomes.tmp ${tmp_dir}/reporting_SCG_counts_after_len_filt_for_genomes_retained.tmp ${tmp_dir}/reporting_that_in_final_tree_column.tmp > ${tmp_dir}/building_genomes_tab.tmp

fi


# and adding header and writing to output directory
cat <(printf "assembly_id\ttaxid\tnum_SCG_hits\tuniq_SCG_hits\tperc_comp\tperc_redund\tnum_SCG_hits_after_len_filt\tin_final_tree\n") ${tmp_dir}/building_genomes_tab.tmp > ${output_dir}/Genomes_summary_info.tsv

#############################################################################
############  FORMATTING TABLE FOR THOSE WITH >= 10% REDUNDANCY  ############
#############################################################################

if [ -f ${tmp_dir}/Genomes_with_questionable_redundancy_estimates.tmp ]; then
    cat <(printf "assembly_id\tnum_SCG_hits\tuniq_SCG_hits\tperc_comp\tperc_redund\n") ${tmp_dir}/Genomes_with_questionable_redundancy_estimates.tmp > ${output_dir}/Genomes_with_questionable_redundancy_estimates.tsv
fi

#############################################################################
#####################  CATTING ALL ALIGNMENTS TOGETHER  #####################
#############################################################################
printf "\n ############################################################################## \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
printf " ####                  Catting all alignments together                     ####\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
printf " ############################################################################## \n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

curr_time=$(date +"%I:%M %p")
duration=$SECONDS

printf "           It is currently $curr_time; the process started at $start_time.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
printf "               Current process runtime: $(($duration / 60 / 60)) hours and $((($duration / 60) % 60)) minutes.\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

# this concatenates the alignments and generates the partitions file for mixed model alignments
if [ $nucleotide != 'false' ]; then
    gtt-cat-alignments -t $tmp_dir -o $output_dir --nucleotides
else
    gtt-cat-alignments -t $tmp_dir -o $output_dir
fi

# storing genomes that made it through workflow to report at end
genomes_retained=$(wc -l ${tmp_dir}/final_genomes_from_all_sources.tmp | sed "s/^ *//" | cut -d " " -f 1)

printf "\n________________________________________________________________________________\n\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

#############################################################################
##############  ADDING MORE INFORMATIVE HEADERS IF SPECIFIED  ###############
#############################################################################
## making copy of alignment file to preserve original
if [ -n "$new_file_to_genome_id_map" ] || [ $taxonkit_id_swap != "false" ] || [ $gtdb_id_swap != "false" ] ; then

    echo $lineage_spec | tr "," "\n" > ${tmp_dir}/wanted_ranks.tmp

    cp ${output_dir}/Aligned_SCGs${target_gene_suffix} ${tmp_dir}/aligned_SCGs_mod_names.tmp

    printf "\n ############################################################################## \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    printf " ####                   Adding more informative headers                    ####\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    printf " ############################################################################## \n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

    ## building id swap file starting with user-provided Genome-to-ID mapping file if given
    if [ -n "$new_file_to_genome_id_map" ]; then

        sort -k 1,1 $new_file_to_genome_id_map | tee ${tmp_dir}/sorted_id_swap_map.tmp | cut -f1 > ${tmp_dir}/sorted_target_ids_to_swap.tmp

        ## separating out which ones are to be swapped that are ncbi accessions (because the others need to have their extensions removed)
        if [ -f ${output_dir}/NCBI_genomes_summary_info.tsv ]; then

        for acc in $(cut -f 1 ${output_dir}/NCBI_genomes_summary_info.tsv | tail -n +2)
        do
            grep -w -m1 "$acc" ${tmp_dir}/sorted_id_swap_map.tmp
        done | sort -k 1,1 | tee ${tmp_dir}/ncbi_id_swap_map.tmp | cut -f 1 > ${tmp_dir}/sorted_ncbi_ids_to_swap.tmp

        fi

        ## if there are ncbi accession to change, getting which are NOT ncbi accessions, and removing extensions
        ## otherwise moving all to non-ncbi-ids-to-swap and removing extensions
        if [ -s ${tmp_dir}/sorted_ncbi_ids_to_swap.tmp ]; then

            comm -23 ${tmp_dir}/sorted_target_ids_to_swap.tmp ${tmp_dir}/sorted_ncbi_ids_to_swap.tmp | sort > ${tmp_dir}/sorted_non_ncbi_ids_to_swap.tmp

            if [ -s ${tmp_dir}/sorted_non_ncbi_ids_to_swap.tmp ]; then

            # making sure files being appended to are starting empty
            rm -f ${tmp_dir}/non_ncbi_swap_map_p1.tmp ${tmp_dir}/non_ncbi_swap_map_p2.tmp

            for file in $(cat ${tmp_dir}/sorted_non_ncbi_ids_to_swap.tmp)
            do
                non_gz_file_name=$(echo $file | sed 's/.gz//')
                echo "${non_gz_file_name%.*}" >> ${tmp_dir}/non_ncbi_swap_map_p1.tmp
                grep -w -m1 "^${file}" ${tmp_dir}/sorted_id_swap_map.tmp | cut -f 2- >> ${tmp_dir}/non_ncbi_swap_map_p2.tmp
            done

            paste ${tmp_dir}/non_ncbi_swap_map_p1.tmp ${tmp_dir}/non_ncbi_swap_map_p2.tmp | sort -k 1,1 > ${tmp_dir}/sorted_non_ncbi_swap_map.tmp

            fi

        else

            # making sure files being appended to are starting empty
            rm -f ${tmp_dir}/non_ncbi_swap_map_p1.tmp ${tmp_dir}/non_ncbi_swap_map_p2.tmp

            for file in $(cat ${tmp_dir}/sorted_target_ids_to_swap.tmp)
            do
                non_gz_file_name=$(echo "$file" | sed 's/.gz//')
                echo "${non_gz_file_name%.*}" >> ${tmp_dir}/non_ncbi_swap_map_p1.tmp
                grep -w -m1 "^${file}" ${tmp_dir}/sorted_id_swap_map.tmp | cut -f 2- >> ${tmp_dir}/non_ncbi_swap_map_p2.tmp
            done

            paste ${tmp_dir}/non_ncbi_swap_map_p1.tmp ${tmp_dir}/non_ncbi_swap_map_p2.tmp | sort -k 1,1 > ${tmp_dir}/sorted_non_ncbi_swap_map.tmp

        fi

        ## updating id_swap_map
        if [ -f ${tmp_dir}/ncbi_id_swap_map.tmp ] && [ -f ${tmp_dir}/sorted_non_ncbi_swap_map.tmp ]; then
            cat ${tmp_dir}/ncbi_id_swap_map.tmp ${tmp_dir}/sorted_non_ncbi_swap_map.tmp > ${tmp_dir}/id_swap_map.tmp
        elif [ -f ${tmp_dir}/ncbi_id_swap_map.tmp ] && [ ! -f ${tmp_dir}/sorted_non_ncbi_swap_map.tmp ]; then
            cp ${tmp_dir}/ncbi_id_swap_map.tmp ${tmp_dir}/id_swap_map.tmp
        elif [ ! -f ${tmp_dir}/ncbi_id_swap_map.tmp ] && [ -f ${tmp_dir}/sorted_non_ncbi_swap_map.tmp ]; then
            cp ${tmp_dir}/sorted_non_ncbi_swap_map.tmp ${tmp_dir}/id_swap_map.tmp
        fi

        ## splitting mapping file into those that have specific labels to swap and those that need appending
        awk ' BEGIN { FS=OFS="\t" } $2 != "" { print $1,$2 } ' ${tmp_dir}/id_swap_map.tmp > ${tmp_dir}/base_label_swap.tmp

        ## now splitting the file down to those that have labels to append (getting to this part after taxonomy)
        awk ' BEGIN { FS=OFS="\t" } $3 != "" { print $1,$3 } ' ${tmp_dir}/id_swap_map.tmp > ${tmp_dir}/base_labels_need_append.tmp

        ## getting file of those that solely want appending
        awk ' BEGIN { FS=OFS="\t" } $3 != "" && $2 == "" { print $1,$3 } ' ${tmp_dir}/id_swap_map.tmp > ${tmp_dir}/base_labels_that_only_need_append.tmp

    fi

    ## now if taxonkit was specified, adding those to swap file too, but only
    ## renaming genomes with a taxid that are NOT given a new name in the user-provided mapping file (those solely appended-to still have lineages added first)
    if [ $taxonkit_id_swap != "false" ]; then

        ### checking there are actually some taxids to work with, if not, then printing message at end that no lineage info added
        taxid_counts=$(cut -f 2 ${output_dir}/Genomes_summary_info.tsv | sed '/^NA$/d' | wc -l | sed 's/^ *//')

        if [ $taxid_counts -gt 1 ]; then

            ## running taxonkit and adding to summary table ##
            cut -f 2 ${output_dir}/Genomes_summary_info.tsv | tail -n +2 | taxonkit lineage | taxonkit reformat -r NA | cut -f3 | tr ";" "\t" > ${tmp_dir}/lineages.tmp

            cat <(printf "NCBI_domain\tNCBI_phylum\tNCBI_class\tNCBI_order\tNCBI_family\tNCBI_genus\tNCBI_species\n") ${tmp_dir}/lineages.tmp > ${tmp_dir}/lineages2.tmp

            paste ${output_dir}/Genomes_summary_info.tsv ${tmp_dir}/lineages2.tmp > ${output_dir}/All_genomes_summary_info2.tsv
            mv ${output_dir}/All_genomes_summary_info2.tsv ${output_dir}/Genomes_summary_info.tsv

            ## getting genomes that have a taxid
            awk ' BEGIN { FS=OFS="\t" } $2 != "NA" ' ${output_dir}/Genomes_summary_info.tsv | tail -n +2 | cut -f1 > ${tmp_dir}/potential_ids_for_swap.tmp
            ## removing those that the user already provided new labels for, if they did
            if [ -f ${tmp_dir}/base_label_swap.tmp ]; then
                comm -23 <(sort ${tmp_dir}/potential_ids_for_swap.tmp) <(cut -f1 ${tmp_dir}/base_label_swap.tmp | sort) > ${tmp_dir}/ids_for_taxonkit_swap.tmp
            else
                sort ${tmp_dir}/potential_ids_for_swap.tmp > ${tmp_dir}/ids_for_taxonkit_swap.tmp
            fi

            ## creating new labels for them based on lineage info
            for id in $(cat ${tmp_dir}/ids_for_taxonkit_swap.tmp)
            do
                grep -w -m1 "$id" ${output_dir}/Genomes_summary_info.tsv
            done | cut -f 1,9-15 > ${tmp_dir}/working_taxonkit_lineages.tmp

            ## builing new taxonkit-swapped labels based upon user-desired ranks (provided by -L flag)
            cut -f1 ${tmp_dir}/working_taxonkit_lineages.tmp > ${tmp_dir}/building_new_ids_for_taxonkit_swap.tmp

            if grep -q "Domain" ${tmp_dir}/wanted_ranks.tmp; then
                paste -d "_" ${tmp_dir}/building_new_ids_for_taxonkit_swap.tmp <(cut -f 2 ${tmp_dir}/working_taxonkit_lineages.tmp | tr " " "_" | tr "(" "_" | tr ")" "_" | tr "/" "_" | sed 's/__/_/g' | sed 's/_$//' | tr -d "[';\[\]]") > ${tmp_dir}/building_new_ids_for_taxonkit_swap2.tmp
                mv ${tmp_dir}/building_new_ids_for_taxonkit_swap2.tmp ${tmp_dir}/building_new_ids_for_taxonkit_swap.tmp
            fi

            if grep -q "Phylum" ${tmp_dir}/wanted_ranks.tmp; then
                paste -d "_" ${tmp_dir}/building_new_ids_for_taxonkit_swap.tmp <(cut -f 3 ${tmp_dir}/working_taxonkit_lineages.tmp | tr " " "_" | tr "(" "_" | tr ")" "_" | tr "/" "_" | sed 's/__/_/g' | sed 's/_$//' | tr -d "[';\[\]]") > ${tmp_dir}/building_new_ids_for_taxonkit_swap2.tmp
                mv ${tmp_dir}/building_new_ids_for_taxonkit_swap2.tmp ${tmp_dir}/building_new_ids_for_taxonkit_swap.tmp
            fi

            if grep -q "Class" ${tmp_dir}/wanted_ranks.tmp; then
                paste -d "_" ${tmp_dir}/building_new_ids_for_taxonkit_swap.tmp <(cut -f 4 ${tmp_dir}/working_taxonkit_lineages.tmp | tr " " "_" | tr "(" "_" | tr ")" "_" | tr "/" "_" | sed 's/__/_/g' | sed 's/_$//' | tr -d "[';\[\]]") > ${tmp_dir}/building_new_ids_for_taxonkit_swap2.tmp
                mv ${tmp_dir}/building_new_ids_for_taxonkit_swap2.tmp ${tmp_dir}/building_new_ids_for_taxonkit_swap.tmp
            fi

            if grep -q "Order" ${tmp_dir}/wanted_ranks.tmp; then
                paste -d "_" ${tmp_dir}/building_new_ids_for_taxonkit_swap.tmp <(cut -f 5 ${tmp_dir}/working_taxonkit_lineages.tmp | tr " " "_" | tr "(" "_" | tr ")" "_" | tr "/" "_" | sed 's/__/_/g' | sed 's/_$//' | tr -d "[';\[\]]") > ${tmp_dir}/building_new_ids_for_taxonkit_swap2.tmp
                mv ${tmp_dir}/building_new_ids_for_taxonkit_swap2.tmp ${tmp_dir}/building_new_ids_for_taxonkit_swap.tmp
            fi

            if grep -q "Family" ${tmp_dir}/wanted_ranks.tmp; then
                paste -d "_" ${tmp_dir}/building_new_ids_for_taxonkit_swap.tmp <(cut -f 6 ${tmp_dir}/working_taxonkit_lineages.tmp | tr " " "_" | tr "(" "_" | tr ")" "_" | tr "/" "_" | sed 's/__/_/g' | sed 's/_$//' | tr -d "[';\[\]]") > ${tmp_dir}/building_new_ids_for_taxonkit_swap2.tmp
                mv ${tmp_dir}/building_new_ids_for_taxonkit_swap2.tmp ${tmp_dir}/building_new_ids_for_taxonkit_swap.tmp
            fi

            if grep -q "Genus" ${tmp_dir}/wanted_ranks.tmp; then
                paste -d "_" ${tmp_dir}/building_new_ids_for_taxonkit_swap.tmp <(cut -f 7 ${tmp_dir}/working_taxonkit_lineages.tmp | tr " " "_" | tr "(" "_" | tr ")" "_" | tr "/" "_" | sed 's/__/_/g' | sed 's/_$//' | tr -d "[';\[\]]") > ${tmp_dir}/building_new_ids_for_taxonkit_swap2.tmp
                mv ${tmp_dir}/building_new_ids_for_taxonkit_swap2.tmp ${tmp_dir}/building_new_ids_for_taxonkit_swap.tmp
            fi

            if grep -q "Species" ${tmp_dir}/wanted_ranks.tmp; then
                paste -d "_" ${tmp_dir}/building_new_ids_for_taxonkit_swap.tmp <(cut -f 8 ${tmp_dir}/working_taxonkit_lineages.tmp | tr "." "_" | tr " " "_" | tr "(" "_" | tr ")" "_" | tr "/" "_" | sed 's/__/_/g' | sed 's/_$//' | tr -d "[';\[\]]") > ${tmp_dir}/building_new_ids_for_taxonkit_swap2.tmp
                mv ${tmp_dir}/building_new_ids_for_taxonkit_swap2.tmp ${tmp_dir}/building_new_ids_for_taxonkit_swap.tmp
            fi

            mv ${tmp_dir}/building_new_ids_for_taxonkit_swap.tmp ${tmp_dir}/new_ids_for_taxonkit_swap.tmp

            ## making map for IDs changed with taxonkit
            paste ${tmp_dir}/ids_for_taxonkit_swap.tmp ${tmp_dir}/new_ids_for_taxonkit_swap.tmp > ${tmp_dir}/taxonkit_id_swap_map.tmp

            #### adding on infraspecific names if they exist and if Strain-level ranks desired (specified in -L flag)
            if grep -q "Strain" ${tmp_dir}/wanted_ranks.tmp; then

                # these only exist if NCBI accessions were given or if they were found in provided genbank files, so using the ${output_dir}/NCBI_genomes_summary_info.tsv and ${output_dir}/Genbank_genomes_summary_info.tsv files
                if [ -f ${output_dir}/NCBI_genomes_summary_info.tsv ] || [ -f ${output_dir}/Genbank_genomes_summary_info.tsv ]; then

                    # input-ncbi accessions to add strain info to:
                    if [ -f ${output_dir}/NCBI_genomes_summary_info.tsv ]; then

                        for id in $(cat ${tmp_dir}/ids_for_taxonkit_swap.tmp)
                        do
                            grep -m1 -w "$id" ${output_dir}/NCBI_genomes_summary_info.tsv
                        done > ${tmp_dir}/ncbi_genomes_summary_subset_for_id_change.tmp

                        # getting the ids and strains of those that have infraspecific names
                        grep "strain=" ${tmp_dir}/ncbi_genomes_summary_subset_for_id_change.tmp | cut -f 1,6 | sed 's/strain=//' | tr " " "_" | tr "(" "_" | tr ")" "_" | tr "/" "_" | sed 's/__/_/g' | sed 's/_$//' | tr -d "[';\[\]]" > ${tmp_dir}/strain_info_tab.tmp

                    fi

                    # input-genbank labels to add strain info to:
                    if [ -f ${output_dir}/Genbank_genomes_summary_info.tsv ]; then

                        for id in $(cat ${tmp_dir}/ids_for_taxonkit_swap.tmp)
                        do
                            grep -m1 -w "$id" ${output_dir}/Genbank_genomes_summary_info.tsv
                        done > ${tmp_dir}/genbank_genomes_summary_subset_for_id_change.tmp

                        # getting the ids and strains of those that have strains IDs:
                        awk ' BEGIN { FS=OFS="\t" } $5 != "NA" { print $1,$5 } ' ${tmp_dir}/genbank_genomes_summary_subset_for_id_change.tmp | tr " " "_" | tr "(" "_" | tr ")" "_" | tr "/" "_" | sed 's/__/_/g' | sed 's/_$//' | tr -d "[';\[\]]" >> ${tmp_dir}/strain_info_tab.tmp

                    fi

                    sort -k 1,1 ${tmp_dir}/strain_info_tab.tmp > ${tmp_dir}/sorted_strain_info_tab.tmp
                    cut -f 1 ${tmp_dir}/sorted_strain_info_tab.tmp > ${tmp_dir}/sorted_ids_with_strain_info.tmp
                    cut -f 2 ${tmp_dir}/sorted_strain_info_tab.tmp > ${tmp_dir}/sorted_strain_info.tmp

                    # finding which IDs don't get this change, so we can separate them
                    comm -23 ${tmp_dir}/ids_for_taxonkit_swap.tmp ${tmp_dir}/sorted_ids_with_strain_info.tmp > ${tmp_dir}/taxonkit_ids_to_not_change.tmp
                    # pulling out the ones we're not changing only, to use them to create a file of those we are changing
                    for i in $(cat ${tmp_dir}/taxonkit_ids_to_not_change.tmp)
                    do
                        grep -w -m1 "$i" ${tmp_dir}/taxonkit_id_swap_map.tmp
                    done > ${tmp_dir}/building_final_taxonkit_id_swap_map.tmp

                    # now pulling out only those we are adding to
                    for i in $(cat ${tmp_dir}/sorted_ids_with_strain_info.tmp)
                    do
                        grep -w -m1 "$i" ${tmp_dir}/taxonkit_id_swap_map.tmp
                    done > ${tmp_dir}/building_final_taxonkit_id_swap_map_to_paste_onto.tmp

                    # now adding strain labels
                    paste -d "_" ${tmp_dir}/building_final_taxonkit_id_swap_map_to_paste_onto.tmp ${tmp_dir}/sorted_strain_info.tmp > ${tmp_dir}/building_final_taxonkit_id_swap_map2.tmp

                    cat ${tmp_dir}/building_final_taxonkit_id_swap_map.tmp ${tmp_dir}/building_final_taxonkit_id_swap_map2.tmp > ${tmp_dir}/final_taxonkit_id_swap_map.tmp

                fi

            else
                cp ${tmp_dir}/taxonkit_id_swap_map.tmp ${tmp_dir}/final_taxonkit_id_swap_map.tmp
            fi

            ## pasting together and adding to the ${tmp_dir}/base_label_swap.tmp if other user-specified IDs were given (with -m flag)
            if [ -f ${tmp_dir}/base_label_swap.tmp ]; then
                cat ${tmp_dir}/base_label_swap.tmp ${tmp_dir}/final_taxonkit_id_swap_map.tmp > ${tmp_dir}/full_id_swap_map.tmp
            else
                cp ${tmp_dir}/final_taxonkit_id_swap_map.tmp ${tmp_dir}/full_id_swap_map.tmp
            fi

        else # this is if there are no taxids to use for taxonkit
            printf "  ${YELLOW}********************************** ${NC}NOTICE ${YELLOW}**********************************${NC}\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf "    You specified to use Taxonkit to add lineage info (set with the '-t' flag),\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf "    but there were no taxids available (which typically come from inputs provided\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf "    as NCBI accessions or GenBank files that might hold that information).\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf "    In this case no lineage information could be added.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf "  ${YELLOW}***************************************************************************** ${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

            # if base label swap map was provided by the user (via the -m flag) then making that the final swap map since no taxonkit lineage info to add
            if [ -f ${tmp_dir}/base_label_swap.tmp ]; then
                cp ${tmp_dir}/base_label_swap.tmp ${tmp_dir}/full_id_swap_map.tmp
            fi
        fi

    else
        ## if no taxonkit swapping specified, moving user-provided map to final file if it exists
        if [ -f ${tmp_dir}/base_label_swap.tmp ]; then

            cp ${tmp_dir}/base_label_swap.tmp ${tmp_dir}/full_id_swap_map.tmp

        fi
    fi

    ## now if using gtdb lineage info was requested, adding those to swap file too (superceding if taxonkit was also used), and
    ## re-labeling genomes that were NOT given a new name in the user-provided mapping file (those solely appended-to will still have lineages added first)
    if [ $gtdb_id_swap != "false" ]; then

        # ref files were checked for and downloaded if needed above, before main program started

        # getting genomes that have a taxid (possibly found from a genbank file) and if its entry starts like an NCBI accession (which we may be able to find in GTDB)
        awk ' BEGIN { FS=OFS="\t" } $2 != "NA" ' ${output_dir}/Genomes_summary_info.tsv | tail -n +2 | cut -f 1 | grep "^GC._" > ${tmp_dir}/potential_ids_for_gtdb_swap.tmp

        # creating subset gtdb table holding all target accessions (in case the user providing a mapping file that supersedes re-labeling any of these, but still wants the gtdb taxonomy and other information for the entry)
        gtt-parse-gtdb-assembly-summary-file -o ${tmp_dir}/target-gtdb.tsv -f ${tmp_dir}/gtdb_found_accs.tsv -n ${tmp_dir}/gtdb-not-found-accs.tsv -t ${tmp_dir}/target-gtdb-tax.tsv -a ${GTDB_dir}/GTDB-arc-and-bac-metadata.tsv -w ${tmp_dir}/potential_ids_for_gtdb_swap.tmp

        ## there are no strain level designations in GTDB, so those will be absent on any labels where GTDB taxonomy was added if requested by the user
            # notifying user here if this is the case
        if [ -n ${tmp_dir}/wanted_ranks.tmp ]; then
            if grep -q "Strain" ${tmp_dir}/wanted_ranks.tmp; then
                printf "  ${YELLOW}********************************** ${NC}NOTICE ${YELLOW}**********************************${NC}  \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
                printf "    Strain-level labels were requested in addition to using GTDB taxonomy\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
                printf "    where possible. This is just a note that there will be no strain-level\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
                printf "    labels added for those that had GTDB lineage info added.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
                printf "  ${YELLOW}****************************************************************************${NC}  \n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            fi
        fi

        ## reporting to user how many entries were tried and found at GTDB
        if [ -s ${tmp_dir}/gtdb-not-found-accs.tsv ]; then

            num_entries_found=$(tail -n +2 ${tmp_dir}/gtdb_found_accs.tsv | wc -l | sed "s/^ *//" | cut -d " " -f 1)
            num_entries_not_found=$(tail -n +2 ${tmp_dir}/gtdb-not-found-accs.tsv | wc -l | sed "s/^ *//" | cut -d " " -f 1)
            num_entries_searched=$(($num_entries_found + $num_entries_not_found))
            printf "\n  ${YELLOW}********************************** ${NC}NOTICE ${YELLOW}**********************************${NC}  \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf "    $num_entries_not_found accession(s) of the searched $num_entries_searched were not successfully found in GTDB.\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf "    Reported in \"${output_dir}/run_files/GTDB_accessions_not_found.tsv\".\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf "  ${YELLOW}****************************************************************************${NC}  \n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

            sleep 3

            cp ${tmp_dir}/gtdb-not-found-accs.tsv ${output_dir}/run_files/GTDB_accessions_not_found.tsv

        fi

        # storing IDs for which a GTDB entry was found:
        cut -f 1 ${tmp_dir}/gtdb_found_accs.tsv | tail -n +2 > ${tmp_dir}/found_ids_for_gtdb_swap.tmp

            # copying keeper files to output dir
        cp ${tmp_dir}/target-gtdb.tsv ${output_dir}/run_files/GTDB_genomes_summary_info.tsv
        cp ${tmp_dir}/gtdb_found_accs.tsv ${output_dir}/run_files/GTDB_to_input_accession_map.tsv

        # now moving on to the swapping, removing those that the user already provided new labels for, if they did
        if [ -f ${tmp_dir}/base_label_swap.tmp ]; then
            comm -23 <(sort ${tmp_dir}/found_ids_for_gtdb_swap.tmp) <(cut -f 1 ${tmp_dir}/base_label_swap.tmp | sort) > ${tmp_dir}/ids_for_gtdb_swap.tmp
        else
            sort ${tmp_dir}/found_ids_for_gtdb_swap.tmp > ${tmp_dir}/ids_for_gtdb_swap.tmp
        fi

        ## adding GTDB taxonomy to final genome summary table for those that have it
            # first need to separate out those that have gtdb info from those that don't
        for id in $(cat ${tmp_dir}/ids_for_gtdb_swap.tmp)
        do
            grep -w -m 1 ^$id ${output_dir}/Genomes_summary_info.tsv
        done > ${tmp_dir}/gtdb_rows_that_need_tax_info_added.tmp

        comm -23 <(cut -f 1 ${output_dir}/Genomes_summary_info.tsv | tail -n +2 | sort) <(sort ${tmp_dir}/ids_for_gtdb_swap.tmp) > ${tmp_dir}/ids_that_need_NAs_added_for_gtdb_info.tmp
        for id in $(cat ${tmp_dir}/ids_that_need_NAs_added_for_gtdb_info.tmp)
        do
            grep -w -m 1 ^$id ${output_dir}/Genomes_summary_info.tsv
        done > ${tmp_dir}/rows_that_need_NAs_added_for_gtdb_info.tmp

            # adding tax info to those that have gtdb info
        for id in $(cat ${tmp_dir}/ids_for_gtdb_swap.tmp)
        do
            grep -w -m 1 ^$id ${output_dir}/run_files/GTDB_to_input_accession_map.tsv
        done | cut -f 2 > ${tmp_dir}/base_ids_for_gtdb_swap.tmp

        for id in $(cat ${tmp_dir}/base_ids_for_gtdb_swap.tmp)
        do
            grep -w -m 1 ^$id ${tmp_dir}/target-gtdb-tax.tsv
        done | cut -f 2- > ${tmp_dir}/gtdb_tax_to_add_to_rows.tmp

        paste ${tmp_dir}/gtdb_rows_that_need_tax_info_added.tmp ${tmp_dir}/gtdb_tax_to_add_to_rows.tmp > ${tmp_dir}/rows_for_genome_summary_table_with_gtdb_tax_info.tmp

            # adding NAs for these columns for those that don't have gtdb info
        for id in $(cat ${tmp_dir}/ids_that_need_NAs_added_for_gtdb_info.tmp)
        do
            printf "NA\tNA\tNA\tNA\tNA\tNA\tNA\tNA\n"
        done > ${tmp_dir}/NAs_for_gtdb_tax_to_add_to_rows.tmp

        paste ${tmp_dir}/rows_that_need_NAs_added_for_gtdb_info.tmp ${tmp_dir}/NAs_for_gtdb_tax_to_add_to_rows.tmp > ${tmp_dir}/rows_for_genome_summary_table_without_gtdb_tax_info.tmp

            # sticking together with an expanded header to make the genome summary output table
        head -n 1 ${output_dir}/Genomes_summary_info.tsv > ${tmp_dir}/curr_genome_summary_header.tmp
        paste ${tmp_dir}/curr_genome_summary_header.tmp <(printf "GTDB_accession\tGTDB_domain\tGTDB_phylum\tGTDB_class\tGTDB_order\tGTDB_family\tGTDB_genus\tGTDB_species\n") > ${tmp_dir}/new_genome_summary_header.tmp

        cat ${tmp_dir}/new_genome_summary_header.tmp ${tmp_dir}/rows_for_genome_summary_table_with_gtdb_tax_info.tmp ${tmp_dir}/rows_for_genome_summary_table_without_gtdb_tax_info.tmp > ${output_dir}/Genomes_summary_info.tsv

        ## creating new labels based on GTDB lineage info
        for id in $(cat ${tmp_dir}/ids_for_gtdb_swap.tmp)
        do
            grep -w -m 1 "$id" ${tmp_dir}/gtdb_found_accs.tsv | cut -f 2
        done > ${tmp_dir}/gtdb_found_accs_to_pull_lineage_info_for.tmp

        for id in $(cat ${tmp_dir}/gtdb_found_accs_to_pull_lineage_info_for.tmp)
        do
            grep -w -m 1 "^$id" ${tmp_dir}/target-gtdb-tax.tsv
        done | cut -f 1,3-9 > ${tmp_dir}/working_gtdb_lineages.tmp

        ## buildig new gtdb-swapped labels based upon user-desired ranks (provided by -L flag)
        cut -f 1 ${tmp_dir}/working_gtdb_lineages.tmp > ${tmp_dir}/building_new_ids_for_gtdb_swap.tmp

        if grep -q "Domain" ${tmp_dir}/wanted_ranks.tmp; then
            paste -d "_" ${tmp_dir}/building_new_ids_for_gtdb_swap.tmp <(cut -f 2 ${tmp_dir}/working_gtdb_lineages.tmp | tr " " "_" | tr "(" "_" | tr ")" "_" | tr "/" "_" | sed 's/__/_/g' | sed 's/_$//' | tr -d "[';\[\]]") > ${tmp_dir}/building_new_ids_for_gtdb_swap2.tmp
            mv ${tmp_dir}/building_new_ids_for_gtdb_swap2.tmp ${tmp_dir}/building_new_ids_for_gtdb_swap.tmp
        fi

        if grep -q "Phylum" ${tmp_dir}/wanted_ranks.tmp; then
            paste -d "_" ${tmp_dir}/building_new_ids_for_gtdb_swap.tmp <(cut -f 3 ${tmp_dir}/working_gtdb_lineages.tmp | tr " " "_" | tr "(" "_" | tr ")" "_" | tr "/" "_" | sed 's/__/_/g' | sed 's/_$//' | tr -d "[';\[\]]") > ${tmp_dir}/building_new_ids_for_gtdb_swap2.tmp
            mv ${tmp_dir}/building_new_ids_for_gtdb_swap2.tmp ${tmp_dir}/building_new_ids_for_gtdb_swap.tmp
        fi

        if grep -q "Class" ${tmp_dir}/wanted_ranks.tmp; then
            paste -d "_" ${tmp_dir}/building_new_ids_for_gtdb_swap.tmp <(cut -f 4 ${tmp_dir}/working_gtdb_lineages.tmp | tr " " "_" | tr "(" "_" | tr ")" "_" | tr "/" "_" | sed 's/__/_/g' | sed 's/_$//' | tr -d "[';\[\]]") > ${tmp_dir}/building_new_ids_for_gtdb_swap2.tmp
            mv ${tmp_dir}/building_new_ids_for_gtdb_swap2.tmp ${tmp_dir}/building_new_ids_for_gtdb_swap.tmp
        fi

        if grep -q "Order" ${tmp_dir}/wanted_ranks.tmp; then
            paste -d "_" ${tmp_dir}/building_new_ids_for_gtdb_swap.tmp <(cut -f 5 ${tmp_dir}/working_gtdb_lineages.tmp | tr " " "_" | tr "(" "_" | tr ")" "_" | tr "/" "_" | sed 's/__/_/g' | sed 's/_$//' | tr -d "[';\[\]]") > ${tmp_dir}/building_new_ids_for_gtdb_swap2.tmp
            mv ${tmp_dir}/building_new_ids_for_gtdb_swap2.tmp ${tmp_dir}/building_new_ids_for_gtdb_swap.tmp
        fi

        if grep -q "Family" ${tmp_dir}/wanted_ranks.tmp; then
            paste -d "_" ${tmp_dir}/building_new_ids_for_gtdb_swap.tmp <(cut -f 6 ${tmp_dir}/working_gtdb_lineages.tmp | tr " " "_" | tr "(" "_" | tr ")" "_" | tr "/" "_" | sed 's/__/_/g' | sed 's/_$//' | tr -d "[';\[\]]") > ${tmp_dir}/building_new_ids_for_gtdb_swap2.tmp
            mv ${tmp_dir}/building_new_ids_for_gtdb_swap2.tmp ${tmp_dir}/building_new_ids_for_gtdb_swap.tmp
        fi

        if grep -q "Genus" ${tmp_dir}/wanted_ranks.tmp; then
            paste -d "_" ${tmp_dir}/building_new_ids_for_gtdb_swap.tmp <(cut -f 7 ${tmp_dir}/working_gtdb_lineages.tmp | tr " " "_" | tr "(" "_" | tr ")" "_" | tr "/" "_" | sed 's/__/_/g' | sed 's/_$//' | tr -d "[';\[\]]") > ${tmp_dir}/building_new_ids_for_gtdb_swap2.tmp
            mv ${tmp_dir}/building_new_ids_for_gtdb_swap2.tmp ${tmp_dir}/building_new_ids_for_gtdb_swap.tmp
        fi

        if grep -q "Species" ${tmp_dir}/wanted_ranks.tmp; then
            paste -d "_" ${tmp_dir}/building_new_ids_for_gtdb_swap.tmp <(cut -f 8 ${tmp_dir}/working_gtdb_lineages.tmp | tr "." "_" | tr " " "_" | tr "(" "_" | tr ")" "_" | tr "/" "_" | sed 's/__/_/g' | sed 's/_$//' | tr -d "[';\[\]]") > ${tmp_dir}/building_new_ids_for_gtdb_swap2.tmp
            mv ${tmp_dir}/building_new_ids_for_gtdb_swap2.tmp ${tmp_dir}/building_new_ids_for_gtdb_swap.tmp
        fi

        mv ${tmp_dir}/building_new_ids_for_gtdb_swap.tmp ${tmp_dir}/new_ids_for_gtdb_swap.tmp

        ## making map for IDs changed with gtdb
        paste ${tmp_dir}/ids_for_gtdb_swap.tmp ${tmp_dir}/new_ids_for_gtdb_swap.tmp > ${tmp_dir}/final_gtdb_id_swap_map.tmp

        ## now, if there are taxonkit swapped labels, we are replacing those that we cover with GTDB in the full_id_swap_map file...
        if [ -f ${tmp_dir}/final_taxonkit_id_swap_map.tmp ]; then
            # getting those IDs with taxonkit info
            cut -f 1 ${tmp_dir}/final_taxonkit_id_swap_map.tmp | sort > ${tmp_dir}/current_taxonkit_ids_to_swap.tmp
            # getting those IDs with GTDB info
            cut -f 1 ${tmp_dir}/final_gtdb_id_swap_map.tmp | sort > ${tmp_dir}/current_gtdb_ids_to_swap.tmp

            # getting those with taxonkit (NCBI) lineage info, but no GTDB info (will happen in current release of GTDB doesn't include this particular accession)
            comm -23 ${tmp_dir}/current_taxonkit_ids_to_swap.tmp ${tmp_dir}/current_gtdb_ids_to_swap.tmp > ${tmp_dir}/taxonkit_ids_to_keep_because_no_GTDB_info.tmp

            # pulling those out, adding to base label swap file (with a marker that they are from NCBI since both will be mixed), then adding GTDB swap info
            for id in $(cat ${tmp_dir}/taxonkit_ids_to_keep_because_no_GTDB_info.tmp)
            do
                grep -w -m 1 "$id" ${tmp_dir}/full_id_swap_map.tmp | sed 's/$/_NCBI/'
            done > ${tmp_dir}/building_final_lineage_id_swap_map.tmp

            cat ${tmp_dir}/building_final_lineage_id_swap_map.tmp ${tmp_dir}/final_gtdb_id_swap_map.tmp > ${tmp_dir}/final_lineage_id_swap_map.tmp

        else # this is if there were no taxonkit swapping requested
            cp ${tmp_dir}/final_gtdb_id_swap_map.tmp ${tmp_dir}/final_lineage_id_swap_map.tmp

        fi

        ## adding to the ${tmp_dir}/base_label_swap.tmp if other user-specified IDs were given (with -m flag)
        if [ -f ${tmp_dir}/base_label_swap.tmp ]; then
            cat ${tmp_dir}/base_label_swap.tmp ${tmp_dir}/final_lineage_id_swap_map.tmp > ${tmp_dir}/full_id_swap_map.tmp
        else
            cp ${tmp_dir}/final_lineage_id_swap_map.tmp ${tmp_dir}/full_id_swap_map.tmp
        fi


    fi


    ### if some need appending, then appending here
    if [ -s ${tmp_dir}/base_labels_need_append.tmp ]; then

        # getting ids that need appending:
        sort -k 1 ${tmp_dir}/base_labels_need_append.tmp | tee ${tmp_dir}/sorted_base_labels_need_append.tmp | cut -f 1 > ${tmp_dir}/sorted_base_ids_need_append.tmp

        # getting those that don't need appending, so can separate:
        comm -23 <(cut -f 1 ${tmp_dir}/full_id_swap_map.tmp | sort) ${tmp_dir}/sorted_base_ids_need_append.tmp | sort > ${tmp_dir}/sorted_base_ids_no_append.tmp

        # making final swap table of those that don't need appending:
        for non_append_label in $(cat ${tmp_dir}/sorted_base_ids_no_append.tmp)
        do
            grep -m 1 -w "^$non_append_label" ${tmp_dir}/full_id_swap_map.tmp
        done > ${tmp_dir}/p1_final_id_swap_map.tmp

        # getting swap table for those that do need appending:
        for append_label in $(cat ${tmp_dir}/sorted_base_ids_need_append.tmp)
        do
            grep -m 1 -w "^$append_label" ${tmp_dir}/full_id_swap_map.tmp

        done > ${tmp_dir}/p2a_final_id_swap_map.tmp

        # appending labels
        paste -d "_" ${tmp_dir}/p2a_final_id_swap_map.tmp <(cut -f 2 ${tmp_dir}/sorted_base_labels_need_append.tmp) > ${tmp_dir}/p2_final_id_swap_map.tmp

        # sticking together for final label swap:
        cat ${tmp_dir}/p1_final_id_swap_map.tmp ${tmp_dir}/p2_final_id_swap_map.tmp ${tmp_dir}/base_labels_that_only_need_append.tmp > ${tmp_dir}/final_id_swap_map.tmp

    else
        # updating file if not changed
        rm -f ${tmp_dir}/base_labels_need_append.tmp

        if [ -s ${tmp_dir}/full_id_swap_map.tmp ]; then
            cp ${tmp_dir}/full_id_swap_map.tmp ${tmp_dir}/final_id_swap_map.tmp
        fi
    fi

    ## if final_id_swap_map.tmp exists here, moving forward with swap
    ## if it does not exist here (which may happen if Taxonkit or GTDB was specified, but no input sources had any taxids, for example), then not performing id swapping and reporting to user

    if [ -s ${tmp_dir}/final_id_swap_map.tmp ]; then
          ## one last safety screen for colons, commas, semi-colons, and spaces, and if multiple underscores in a row, collapsing to just 1
        paste <(cut -f 1 ${tmp_dir}/final_id_swap_map.tmp) <(cut -f 2,3 ${tmp_dir}/final_id_swap_map.tmp | tr "[:,; ]" "_" | tr -s "_") > ${tmp_dir}/final_id_swap_map_colonless.tmp

        ### now swapping ids
        gtt-swap-ids -i ${tmp_dir}/aligned_SCGs_mod_names.tmp -s ${tmp_dir}/final_id_swap_map_colonless.tmp -o ${output_dir}/Aligned_SCGs_mod_names${target_gene_suffix}

        ### adding new ids to summary table as column "label"
        # first pulling out and adding to those that were changed
        for changed_id in $(cut -f1 ${tmp_dir}/final_id_swap_map_colonless.tmp)
        do
            grep -w -m1 "$changed_id" ${output_dir}/Genomes_summary_info.tsv
        done | cut -f 2- > ${tmp_dir}/building_new_genomes_tab1.tmp

        paste ${tmp_dir}/final_id_swap_map_colonless.tmp ${tmp_dir}/building_new_genomes_tab1.tmp > ${tmp_dir}/building_new_genomes_tab2.tmp

        # now getting those that weren't changed and adding assembly id to the "label" column
        comm -23 <(cut -f1 ${output_dir}/Genomes_summary_info.tsv | tail -n +2 | sort) <(cut -f1 ${tmp_dir}/final_id_swap_map_colonless.tmp | sort) > ${tmp_dir}/unchanged_ids.tmp

        for unchanged_id in $(cat ${tmp_dir}/unchanged_ids.tmp)
        do
            grep -w -m1 "$unchanged_id" ${output_dir}/Genomes_summary_info.tsv
        done > ${tmp_dir}/building_new_genomes_tab3.tmp

        paste ${tmp_dir}/unchanged_ids.tmp ${tmp_dir}/building_new_genomes_tab3.tmp > ${tmp_dir}/building_new_genomes_tab4.tmp

        head -n 1 ${output_dir}/Genomes_summary_info.tsv > ${tmp_dir}/old_header.tmp

        # making new header
        paste <(cut -f 1 ${tmp_dir}/old_header.tmp) <(printf "label") <(cut -f 2- ${tmp_dir}/old_header.tmp) > ${tmp_dir}/new_header.tmp

        # now sticking all together into a new summary table that includes any adjusted labels
        cat ${tmp_dir}/new_header.tmp ${tmp_dir}/building_new_genomes_tab2.tmp ${tmp_dir}/building_new_genomes_tab4.tmp > ${output_dir}/Genomes_summary_info.tsv

        #### adding a "label_source" column to final output genome summary tab (NCBI, GTDB, user_map, user_map_append, input)
            # getting those, if any, that were adjusted by the user input map
        if [ -s ${tmp_dir}/base_label_swap.tmp ]; then
            cut -f 1 ${tmp_dir}/base_label_swap.tmp | sort > ${tmp_dir}/user_label_swapped_ids.tmp
        fi

        if [ -s ${tmp_dir}/base_labels_need_append.tmp ]; then
            cut -f 1 ${tmp_dir}/base_labels_need_append.tmp | sort > ${tmp_dir}/user_label_appended_ids.tmp
        fi

            # getting those, if any, that were adjusted by taxonkit/ncbi or GTDB (taxonkit/NCBI ones will need to have the gtdb ones subtracted if both exist, as giving GTDB precedence)
            # starting with taxonkit
        if [ -s ${tmp_dir}/final_taxonkit_id_swap_map.tmp ]; then
            cut -f 1 ${tmp_dir}/final_taxonkit_id_swap_map.tmp | sort > ${tmp_dir}/initial_taxonkit_label_swapped_ids.tmp

                # now getting those, if any, that were adjusted by GTDB that will then need to be removed from the taxonkit list
            if [ -s ${tmp_dir}/final_gtdb_id_swap_map.tmp ]; then
                cut -f 1 ${tmp_dir}/final_gtdb_id_swap_map.tmp | sort > ${tmp_dir}/gtdb_label_swapped_ids.tmp

                    # getting those which still need the taxonkit label (and aren't superseded by gtdb due to lack of data on that accession)
                comm -23 ${tmp_dir}/initial_taxonkit_label_swapped_ids.tmp ${tmp_dir}/gtdb_label_swapped_ids.tmp | sort > ${tmp_dir}/taxonkit_label_swapped_ids.tmp

            else
                # renaming file that doesn't need to be adjusted due to gtdb labels taking precedence
                cp ${tmp_dir}/initial_taxonkit_label_swapped_ids.tmp ${tmp_dir}/taxonkit_label_swapped_ids.tmp

            fi

        fi

            # getting those, if any, that were adjusted by GTDB
                # only doing if NOT already done in the taxonkit loop above
        if [ ! -s ${tmp_dir}/gtdb_label_swapped_ids.tmp ]; then

            if [ -s ${tmp_dir}/final_gtdb_id_swap_map.tmp ]; then
                cut -f 1 ${tmp_dir}/final_gtdb_id_swap_map.tmp | sort > ${tmp_dir}/gtdb_label_swapped_ids.tmp
            fi

        fi

        ### now making new column for each specifying the "label_source" (e.g. NCBI, GTDB, user_map, user_map_append_to_<X>, input) and re-making final output genome summary tab
            # for user appended ones, will report "<X>_and_appended", with <X> being either "input", "NCBI", "user_map", or "GTDB"

            # wrapping all with appended since need to treat them differently if label was appended to (specified by the 3rd column in the input mapping file passed to '-m')
                # next will be the 'else' where they are each dealt with if no user-appended labels are involved
                    # for each, adding to a file holding all types so at end we can use that to find those that aren't re-labeled by any method (and just have their input labels)
        if [ -s ${tmp_dir}/user_label_appended_ids.tmp ]; then

            # user-map
            if [ -s ${tmp_dir}/user_label_swapped_ids.tmp ]; then

                    # adding to file holding all types so at end we can use that to find those that aren't re-labeled by any method (and just have their input labels)
                cat ${tmp_dir}/user_label_swapped_ids.tmp >> ${tmp_dir}/all_relabeled_ids.tmp

                for id in $(cat ${tmp_dir}/user_label_swapped_ids.tmp)
                do

                    # if label also in user-appended list
                    if grep -q $id ${tmp_dir}/user_label_appended_ids.tmp; then

                        grep -w -m 1 ^$id ${output_dir}/Genomes_summary_info.tsv >> ${tmp_dir}/building_new_genome_summary_tab_with_label_source.tmp
                        printf "user_map_and_appended\n" >> ${tmp_dir}/building_label_source_column.tmp

                    # if label NOT in user-appended list
                    else
                        grep -w -m 1 ^$id ${output_dir}/Genomes_summary_info.tsv >> ${tmp_dir}/building_new_genome_summary_tab_with_label_source.tmp
                        printf "user_map\n" >> ${tmp_dir}/building_label_source_column.tmp

                    fi

                done

            fi

            # taxonkit/NCBI
            if [ -s ${tmp_dir}/taxonkit_label_swapped_ids.tmp ]; then

                # adding to file holding all types so at end we can use that to find those that aren't re-labeled by any method (and just have their input labels)
                cat ${tmp_dir}/taxonkit_label_swapped_ids.tmp >> ${tmp_dir}/all_relabeled_ids.tmp

                for id in $(cat ${tmp_dir}/taxonkit_label_swapped_ids.tmp)
                do

                    # if label also in user-appended list
                    if grep -q $id ${tmp_dir}/user_label_appended_ids.tmp; then

                        grep -w -m 1 ^$id ${output_dir}/Genomes_summary_info.tsv >> ${tmp_dir}/building_new_genome_summary_tab_with_label_source.tmp
                        printf "NCBI_and_appended\n" >> ${tmp_dir}/building_label_source_column.tmp

                    # if label NOT in user-appended list
                    else
                        grep -w -m 1 ^$id ${output_dir}/Genomes_summary_info.tsv >> ${tmp_dir}/building_new_genome_summary_tab_with_label_source.tmp
                        printf "NCBI\n" >> ${tmp_dir}/building_label_source_column.tmp

                    fi

                done

            fi

            # GTDB
            if [ -s ${tmp_dir}/gtdb_label_swapped_ids.tmp ]; then

                # adding to file holding all types so at end we can use that to find those that aren't re-labeled by any method (and just have their input labels)
                cat ${tmp_dir}/gtdb_label_swapped_ids.tmp >> ${tmp_dir}/all_relabeled_ids.tmp

                for id in $(cat ${tmp_dir}/gtdb_label_swapped_ids.tmp)
                do

                    # if label also in user-appended list
                    if grep -q $id ${tmp_dir}/user_label_appended_ids.tmp; then

                        grep -w -m 1 ^$id ${output_dir}/Genomes_summary_info.tsv >> ${tmp_dir}/building_new_genome_summary_tab_with_label_source.tmp
                        printf "GTDB_and_appended\n" >> ${tmp_dir}/building_label_source_column.tmp

                    # if label NOT in user-appended list
                    else
                        grep -w -m 1 ^$id ${output_dir}/Genomes_summary_info.tsv >> ${tmp_dir}/building_new_genome_summary_tab_with_label_source.tmp
                        printf "GTDB\n" >> ${tmp_dir}/building_label_source_column.tmp

                    fi

                done

            fi

            # any getting those that were not re-labeled in any way (user-specified directly, or with any tax info - though may have been appended to)
            # getting file of those not in any of the above
            comm -23 <(cut -f 1 ${output_dir}/Genomes_summary_info.tsv | tail -n +2 | sort) <(sort ${tmp_dir}/all_relabeled_ids.tmp) > ${tmp_dir}/all_NON_relabeled_ids.tmp

            if [ -s ${tmp_dir}/all_NON_relabeled_ids.tmp ]; then

                for id in $(cat ${tmp_dir}/all_NON_relabeled_ids.tmp)
                do

                    # if label also in user-appended list
                    if grep -q $id ${tmp_dir}/user_label_appended_ids.tmp; then

                        # making sure wasn't already found and added from gtdb_label_swapped_ids.tmp
                        if ! grep -q $id ${tmp_dir}/gtdb_label_swapped_ids.tmp > /dev/null 2>&1; then

                            grep -w -m 1 ^$id ${output_dir}/Genomes_summary_info.tsv >> ${tmp_dir}/building_new_genome_summary_tab_with_label_source.tmp
                            printf "input_and_appended\n" >> ${tmp_dir}/building_label_source_column.tmp

                        fi

                    # if label NOT in user-appended list
                    else
                        grep -w -m 1 ^$id ${output_dir}/Genomes_summary_info.tsv >> ${tmp_dir}/building_new_genome_summary_tab_with_label_source.tmp
                        printf "input\n" >> ${tmp_dir}/building_label_source_column.tmp

                    fi

                done

            fi

        ## now handling all if there is no appending going on (specified by column 3 in input mapping file passed to '-m')
        else

            # user-map
            if [ -s ${tmp_dir}/user_label_swapped_ids.tmp ]; then

                # adding to file holding all types so at end we can use that to find those that aren't re-labeled by any method (and just have their input labels)
                cat ${tmp_dir}/user_label_swapped_ids.tmp >> ${tmp_dir}/all_relabeled_ids.tmp

                for id in $(cat ${tmp_dir}/user_label_swapped_ids.tmp)
                do

                    grep -w -m 1 ^$id ${output_dir}/Genomes_summary_info.tsv >> ${tmp_dir}/building_new_genome_summary_tab_with_label_source.tmp
                    printf "user_map\n" >> ${tmp_dir}/building_label_source_column.tmp

                done

            fi

            # taxonkit/NCBI
            if [ -s ${tmp_dir}/taxonkit_label_swapped_ids.tmp ]; then

                # adding to file holding all types so at end we can use that to find those that aren't re-labeled by any method (and just have their input labels)
                cat ${tmp_dir}/taxonkit_label_swapped_ids.tmp >> ${tmp_dir}/all_relabeled_ids.tmp

                for id in $(cat ${tmp_dir}/taxonkit_label_swapped_ids.tmp)
                do

                    grep -w -m 1 ^$id ${output_dir}/Genomes_summary_info.tsv >> ${tmp_dir}/building_new_genome_summary_tab_with_label_source.tmp
                    printf "NCBI\n" >> ${tmp_dir}/building_label_source_column.tmp

                done

            fi

            # GTDB
            if [ -s ${tmp_dir}/gtdb_label_swapped_ids.tmp ]; then

                    # adding to file holding all types so at end we can use that to find those that aren't re-labeled by any method (and just have their input labels)
                cat ${tmp_dir}/gtdb_label_swapped_ids.tmp >> ${tmp_dir}/all_relabeled_ids.tmp

                for id in $(cat ${tmp_dir}/gtdb_label_swapped_ids.tmp)
                do

                    grep -w -m 1 ^$id ${output_dir}/Genomes_summary_info.tsv >> ${tmp_dir}/building_new_genome_summary_tab_with_label_source.tmp
                    printf "GTDB\n" >> ${tmp_dir}/building_label_source_column.tmp

                done

            fi

            # any getting those that were not re-labeled in any way (user-specified directly, or with any tax info)
            # getting file of those not in any of the above
            comm -23 <(cut -f 1 ${output_dir}/Genomes_summary_info.tsv | tail -n +2 | sort) <(sort ${tmp_dir}/all_relabeled_ids.tmp) > ${tmp_dir}/all_NON_relabeled_ids.tmp

            if [ -s ${tmp_dir}/all_NON_relabeled_ids.tmp ]; then

                for id in $(cat ${tmp_dir}/all_NON_relabeled_ids.tmp)
                do

                    grep -w -m 1 ^$id ${output_dir}/Genomes_summary_info.tsv >> ${tmp_dir}/building_new_genome_summary_tab_with_label_source.tmp
                    printf "input\n" >> ${tmp_dir}/building_label_source_column.tmp

                done

            fi

        fi # closing if statement about there being appended labels or not

        ## finally adding additional column to output summary table
            # getting current header and making new one
        head -n 1 ${output_dir}/Genomes_summary_info.tsv > ${tmp_dir}/old_genome_summary_tab_header.tmp
        cut -f 1,2 ${tmp_dir}/old_genome_summary_tab_header.tmp > ${tmp_dir}/new_genome_summary_tab_header_begin.tmp
        cut -f 3- ${tmp_dir}/old_genome_summary_tab_header.tmp > ${tmp_dir}/new_genome_summary_tab_header_end.tmp

        paste ${tmp_dir}/new_genome_summary_tab_header_begin.tmp <(printf "label_source") ${tmp_dir}/new_genome_summary_tab_header_end.tmp > ${tmp_dir}/new_genome_summary_tab_header.tmp

            # splitting apart table and making new one with label source column added in between
        cut -f 1,2 ${tmp_dir}/building_new_genome_summary_tab_with_label_source.tmp > ${tmp_dir}/building_new_genome_summary_tab_with_label_source_begin.tmp
        cut -f 3- ${tmp_dir}/building_new_genome_summary_tab_with_label_source.tmp > ${tmp_dir}/building_new_genome_summary_tab_with_label_source_end.tmp

        paste ${tmp_dir}/building_new_genome_summary_tab_with_label_source_begin.tmp ${tmp_dir}/building_label_source_column.tmp ${tmp_dir}/building_new_genome_summary_tab_with_label_source_end.tmp > ${tmp_dir}/new_genome_summary_tab.tmp

            # adding header
        cat ${tmp_dir}/new_genome_summary_tab_header.tmp ${tmp_dir}/new_genome_summary_tab.tmp > ${output_dir}/Genomes_summary_info.tsv

    else

        printf "  ${YELLOW}********************************** ${NC}NOTICE ${YELLOW}**********************************${NC}\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "    You specified to swap labels either with a specific mapping file (passed\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "    to the '-m' flag) and/or by specifying to add NCBI or GTDB taxonomy info,\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "    but none of these worked out :(\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "    Genomes from your mapping file may have been filtered out, and there may\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "    have been no accessible taxonomy information to retrieve (which typically\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "    would come from inputs provided as NCBI accessions or GenBank files that\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "    might hold that information).\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

        printf "    In this case no labels could be swapped.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "  ${YELLOW}***************************************************************************** ${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

        rm -rf ${tmp_dir}/aligned_SCGs_mod_names.tmp
    fi

    printf "\n________________________________________________________________________________\n\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

fi


#############################################################################
################  COMBINING KO SEARCHING RESULTS IF NEEDED  #################
#############################################################################
if [ ${ko_targets} != 'false' ]; then

    printf "\n ############################################################################## \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    printf " ##########            Combining KO searching results               ###########\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    printf " ############################################################################## \n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

    gtt-combine-kofamscan-results.sh ${tmp_dir}/genomes_from_all_sources.tmp ${tmp_dir} ${output_dir} ${target_KOs}

    gtt-gen-KO-iToL-files.sh ${tmp_dir} ${output_dir}

fi


#############################################################################
##########  WRITING OUT ADDITIONAL TARGET PFAM RESULTS IF NEEDED  ###########
#############################################################################

if [ $additional_pfam_targets != 'false' ]; then

    printf "\n ############################################################################## \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    printf " ####            Parsing results of additional Pfam searches               ####\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    printf " ############################################################################## \n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

    gtt-gen-pfam-iToL-files.sh ${tmp_dir} ${output_dir}

fi


#############################################################################
#############  CLEARING OUT TMP FILES UNLESS -d FLAG PROVIDED  ##############
#############################################################################
# keeping individual alignment files if -k was provided
if [ $keep_individual_alignments == 'true' ]; then
    mkdir ${output_dir}/run_files/individual_alignments

    for file in ${tmp_dir}/*_all_aligned${target_gene_suffix}
    do
        new_path="${output_dir}/run_files/individual_alignments/$(basename $(echo ${file%%_all_aligned${target_gene_suffix}}))_aln${target_gene_suffix}"
        mv ${file} ${new_path}
    done

fi

# saving output dir if -d was provided, removing if not
if [ ${debug_flag} == 'false' ]; then
    rm -rf ${tmp_dir}
else
    mv ${tmp_dir} ${output_dir}
fi


#############################################################################
##############################   MAKING TREE  ###############################
#############################################################################

if [ $align_only == 'false' ]; then

    # alignment file depends on if headers were modified or not
    if [ -s ${output_dir}/Aligned_SCGs_mod_names${target_gene_suffix} ]; then
        alignment_file=${output_dir}/Aligned_SCGs_mod_names${target_gene_suffix}
        tree_file=${output_dir}/Aligned_SCGs_mod_names.tre
    else
        alignment_file=${output_dir}/Aligned_SCGs${target_gene_suffix}
        tree_file=${output_dir}/Aligned_SCGs.tre
    fi

    if [ $tree_program == 'FastTreeMP' ]; then

        printf "\n ############################################################################## \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf " ####                         Running FastTreeMP                           ####\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf " ############################################################################## \n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

        curr_time=$(date +"%I:%M %p")
        duration=$SECONDS

        printf "           It is currently $curr_time; the process started at $start_time.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "               Current process runtime: $(($duration / 60 / 60)) hours and $((($duration / 60) % 60)) minutes.\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

        # setting env variable for FastTreeMP
        export OMP_NUM_THREADS=${num_jobs}

        if [ $nucleotide == 'false' ]; then
            FastTreeMP ${alignment_file} > ${tree_file} 2> >(tee -a $gtotree_log >&2)
        else
            FastTreeMP -nt -gtr ${alignment_file} > ${tree_file} 2> >(tee -a $gtotree_log >&2)
        fi

        fasttree_used="true" # setting to report citations at end

    fi

    if [ $tree_program == 'FastTree' ]; then

        printf "\n ############################################################################## \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf " ####                          Running FastTree                            ####\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf " ############################################################################## \n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

        curr_time=$(date +"%I:%M %p")
        duration=$SECONDS

        printf "           It is currently $curr_time; the process started at $start_time.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "               Current process runtime: $(($duration / 60 / 60)) hours and $((($duration / 60) % 60)) minutes.\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

        if [ $nucleotide == 'false' ]; then
            FastTree ${alignment_file} > ${tree_file} 2> >(tee -a $gtotree_log >&2)
        else
            FastTree -nt -gtr ${alignment_file} > ${tree_file} 2> >(tee -a $gtotree_log >&2)
        fi

        fasttree_used="true" # setting to report citations at end

    fi


    if [ $tree_program == 'VeryFastTree' ]; then

        printf "\n ############################################################################## \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf " ####                        Running VeryFastTree                          ####\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf " ############################################################################## \n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

        curr_time=$(date +"%I:%M %p")
        duration=$SECONDS

        printf "           It is currently $curr_time; the process started at $start_time.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "               Current process runtime: $(($duration / 60 / 60)) hours and $((($duration / 60) % 60)) minutes.\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

        if [ $nucleotide == 'false' ]; then
            VeryFastTree -threads ${num_jobs} ${alignment_file} > ${tree_file} 2> >(tee -a $gtotree_log >&2)
        else
            VeryFastTree -threads ${num_jobs} -nt -gtr ${alignment_file} > ${tree_file} 2> >(tee -a $gtotree_log >&2)
        fi

        veryfasttree_used="true" # setting to report citations at end

    fi


    if [ $tree_program == 'IQ-TREE' ]; then

        printf "\n ############################################################################## \n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf " ####                          Running IQ-TREE                            ####\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf " ############################################################################## \n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

        curr_time=$(date +"%I:%M %p")
        duration=$SECONDS

        printf "           It is currently $curr_time; the process started at $start_time.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "               Current process runtime: $(($duration / 60 / 60)) hours and $((($duration / 60) % 60)) minutes.\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

        # bootstrap only works if at least 4 genomes
        if [ $genomes_retained -ge 4 ]; then

            iqtree -s ${alignment_file} -nt $num_jobs -m MFP -B 1000 -pre iqtree_out | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

        else

            printf "  ${YELLOW}********************************** ${NC}NOTICE ${YELLOW}**********************************${NC}\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf "      Bootstrapping not performed with IQ-TREE with fewer than 4 genomes.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            printf "  ${YELLOW}**************************************************************************** ${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

            iqtree -s ${alignment_file} -nt $num_jobs -m MFP -pre iqtree_out | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

        fi

        mkdir -p ${output_dir}/iqtree_out/
        mv iqtree_out* ${output_dir}/iqtree_out/
        cp ${output_dir}/iqtree_out/iqtree_out.treefile ${tree_file}

        iqtree_used="true" # setting to report citations at end

    fi

fi


#############################################################################
##########################  ORGANIZING OUTPUT DIR  ##########################
#############################################################################
if [ -f ${output_dir}/NCBI_genomes_summary_info.tsv ]; then
    mv ${output_dir}/NCBI_genomes_summary_info.tsv ${output_dir}/run_files/NCBI_genomes_summary_info.tsv
fi

if [ -f ${output_dir}/Genbank_genomes_summary_info.tsv ]; then
    mv ${output_dir}/Genbank_genomes_summary_info.tsv ${output_dir}/run_files/Genbank_genomes_summary_info.tsv
fi

if [ -f ${output_dir}/Fasta_genomes_summary_info.tsv ]; then
    mv ${output_dir}/Fasta_genomes_summary_info.tsv ${output_dir}/run_files/Fasta_genomes_summary_info.tsv
fi

if [ -f ${output_dir}/Amino_acid_genomes_summary_info.tsv ]; then
    mv ${output_dir}/Amino_acid_genomes_summary_info.tsv ${output_dir}/run_files/Amino_acid_genomes_summary_info.tsv
fi


#############################################################################
##########################  JOB-FINISHED REPORTING  #########################
#############################################################################
printf "\n\n#################################################################################\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
printf "####                                 ${GREEN}Done!!${NC}                                  ####\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
printf "#################################################################################\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

# genome report
if [ $genomes_retained == $total_input_genomes ]; then
    printf "            ${GREEN}All $total_input_genomes input genomes were retained through the workflow!${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
else
    printf "  Overall, $genomes_retained genomes of the input $total_input_genomes were retained (see notes below).\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
fi

# reporting primary output files
output_file_prefix=$(basename ${output_dir})

if [ $align_only == 'false' ]; then

    if [ -s ${output_dir}/Aligned_SCGs_mod_names${target_gene_suffix} ]; then

        printf "    Tree written to:\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "        ${GREEN}${output_dir}/${output_file_prefix}.tre${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        mv ${output_dir}/Aligned_SCGs_mod_names.tre ${output_dir}/${output_file_prefix}.tre
    else
        printf "    Tree written to:\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        printf "        ${GREEN}${output_dir}/${output_file_prefix}.tre${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        mv ${output_dir}/Aligned_SCGs.tre ${output_dir}/${output_file_prefix}.tre
    fi

fi

if [ -s ${output_dir}/Aligned_SCGs_mod_names${target_gene_suffix} ]; then
    printf "    Alignment written to:\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    printf "        ${GREEN}${output_dir}/Aligned_SCGs_mod_names${target_gene_suffix}${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    mv ${output_dir}/Aligned_SCGs${target_gene_suffix} ${output_dir}/run_files/Aligned_SCGs${target_gene_suffix}
else
    printf "    Alignment written to:\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    printf "        ${GREEN}${output_dir}/Aligned_SCGs${target_gene_suffix}${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
fi

if [ $keep_individual_alignments == 'true' ]; then
    printf "    Individual protein alignments stored in:\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    printf "        ${GREEN}${output_dir}/run_files/individual_alignments/${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
fi

printf "    Main genomes summary table written to:\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
printf "        ${GREEN}${output_dir}/Genomes_summary_info.tsv${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

printf "    Summary table with hits per target gene per genome written to:\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
printf "        ${GREEN}${output_dir}/SCG_hit_counts.tsv${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )


if [ $ko_targets == 'true' ]; then
    printf "    Outputs from KO searching written to:\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    printf "        ${GREEN}${output_dir}/KO_search_results/${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
fi

if [ $additional_pfam_targets == 'true' ]; then
    printf "    Outputs from Pfam searching written to:\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    printf "        ${GREEN}${output_dir}/Pfam_search_results/${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
fi

printf "    Partitions file (for downstream use with mixed-model treeing) written to:\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
printf "        ${GREEN}${output_dir}/run_files/Partitions.txt${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
mv ${output_dir}/Partitions.txt ${output_dir}/run_files/Partitions.txt

# reporting any problem files/accessions and mentioning run_files/ directory
printf " _______________________________________________________________________________\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

if [ -f ${output_dir}/Redundant_input_accessions.txt ] || [ -f ${output_dir}/NCBI_accessions_not_found.txt ] || [ -f ${output_dir}/NCBI_accessions_not_downloaded.txt ] || [ -f ${output_dir}/Genomes_removed_for_too_few_hits.tsv ] || [ -f ${output_dir}/Genes_with_no_hits_to_any_genomes.txt ] || [ -f ${output_dir}/Genes_with_no_hits_after_length_filter.txt ] || [ -f ${output_dir}/Genomes_with_questionable_redundancy_estimates.tsv ]; then

    printf "  Notes:\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

    if [ -f ${output_dir}/Redundant_input_accessions.txt ]; then
        printf "        $num_dupe_report accession(s) redundant.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        mv ${output_dir}/Redundant_input_accessions.txt ${output_dir}/run_files/Redundant_input_accessions.txt
    fi

    if [ -f ${output_dir}/NCBI_accessions_not_found.txt ]; then
        num_accs_not_found=$(wc -l ${output_dir}/NCBI_accessions_not_found.txt | sed "s/^ *//" | cut -d " " -f 1)
        printf "        $num_accs_not_found accession(s) not successfully found at NCBI.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        mv ${output_dir}/NCBI_accessions_not_found.txt ${output_dir}/run_files/NCBI_accessions_not_found.txt
    fi

    if [ -f ${output_dir}/NCBI_accessions_not_downloaded.txt ]; then
        num_accs_not_downloaded=$(wc -l ${output_dir}/NCBI_accessions_not_downloaded.txt | sed "s/^ *//" | cut -d " " -f 1)
        printf "        $num_accs_not_downloaded did not download properly.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        mv ${output_dir}/NCBI_accessions_not_downloaded.txt ${output_dir}/run_files/NCBI_accessions_not_downloaded.txt
    fi

    if [ -f ${output_dir}/Genomes_removed_for_too_few_hits.tsv ]; then
        printf "        $removed_genomes genome(s) removed due to having too few hits to the targeted SCGs.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        mv ${output_dir}/Genomes_removed_for_too_few_hits.tsv ${output_dir}/run_files/Genomes_removed_for_too_few_hits.tsv
    fi

    # reporting of unsucessful targets depends on if run in best-hit mode (-B) or not
    if [ $best_hit_mode != "true" ]; then

        if [ -f ${output_dir}/run_files/Target-genes-not-found-or-retained.txt ]; then
            printf "        $removed_genes gene(s) either had no hits or only multiple hits in each genome.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        fi

    else

        if [ -f ${output_dir}/Target_genes_not_found.txt ]; then
            printf "        $removed_genes gene(s) had no hits in any genome.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
            mv ${output_dir}/Target_genes_not_found.txt ${output_dir}/run_files/Target_genes_not_found.txt
        fi

    fi


    if [ -f ${output_dir}/Genes_with_no_hits_after_length_filter.txt ]; then
        printf "        $removed_genes2 gene(s) had no hits after filtering by length.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        mv ${output_dir}/Genes_with_no_hits_after_length_filter.txt ${output_dir}/run_files/Genes_with_no_hits_after_length_filter.txt
    fi

    if [ -f ${output_dir}/Genomes_with_questionable_redundancy_estimates.tsv ]; then
        num_genomes_high_redund=$(tail -n +2 ${output_dir}/Genomes_with_questionable_redundancy_estimates.tsv | wc -l | sed "s/^ *//" | cut -d " " -f 1)
        printf "        $num_genomes_high_redund genome(s) had an estimated redundancy of >= 10%%.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
        mv ${output_dir}/Genomes_with_questionable_redundancy_estimates.tsv ${output_dir}/run_files/Genomes_with_questionable_redundancy_estimates.tsv
    fi

    printf "\n    Reported along with additional informative run files in:\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    printf "        ${GREEN}${output_dir}/run_files/${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

else

    printf "    Additional informative run files can be found in:\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
    printf "        ${GREEN}${output_dir}/run_files/${NC}\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

fi

printf " _______________________________________________________________________________\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

# reporting log file output
printf "    Log file written to:\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
printf "        ${GREEN}${output_dir}/gtotree-runlog.txt${NC}\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

printf " _______________________________________________________________________________\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

### checking programs used and reporting a citations file ###
printf "    ${YELLOW}Programs used and their citations have been written to:\n${NC}" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )
printf "        ${GREEN}${output_dir}/citations.txt${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

printf " _______________________________________________________________________________\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

printf "GToTree ${VERSION}\nLee MD. GToTree: a user-friendly workflow for phylogenomics. Bioinformatics. 2019; (March):1-3. doi.org/10.1093/bioinformatics/btz188\n\n" >> ${output_dir}/citations.txt

hmm_version=$(hmmsearch -h | head -n 2 | tail -n 1 | tr -s " " "\t" | cut -f 3)
printf "HMMER3 v${hmm_version}\nEddy SR. Accelerated profile HMM searches. PLoS Comput. Biol. 2011; (7)10. doi.org/10.1371/journal.pcbi.1002195\n\n" >> ${output_dir}/citations.txt

muscle_version=$(muscle -version | tr -s " " "\t" | cut -f 2 | head -n 1)
printf "Muscle ${muscle_version}\nEdgar RC. MUSCLE v5 enables improved estimates of phylogenetic tree confidence by ensemble bootstrapping. bioRxiv. 2021.06.20.449169. doi.org/10.1101/2021.06.20.449169\n\n" >> ${output_dir}/citations.txt

trimal_version=$(trimal --version | grep "trim" | tr -s " " "\t" | cut -f 2)
printf "TrimAl ${trimal_version}\nGutierrez SC. et al. TrimAl: a Tool for automatic alignment trimming. Bioinformatics. 2009; 25, 1972-1973. doi.org/10.1093/bioinformatics/btp348\n\n" >> ${output_dir}/citations.txt

if [ $prodigal_used == "true" ]; then
    prodigal_version=$(prodigal -v 2>&1 | grep Prodigal | tr -s " " "\t" | cut -f 2 | tr -d ":" | sed 's/V/v/')
    printf "Prodigal ${prodigal_version}\nHyatt, D. et al. Gene and translation initiation site prediction in metagenomic sequences. Bioinformatics. 2010; 28, 2223-2230. doi.org/10.1186/1471-2105-11-119\n\n" >> ${output_dir}/citations.txt
fi

if [ $taxonkit_used == "true" ]; then
    taxonkit_version=$(taxonkit -h | grep Version | tr -s " " "\t" | cut -f 2)
    printf "TaxonKit v${taxonkit_version}\nShen W and Ren H. TaxonKit: a practical and efficient NCBI Taxonomy toolkit. Journal of Genetics and Genomics. 2021. doi.org/10.1016/j.jgg.2021.03.006\n\n" >> ${output_dir}/citations.txt
fi

if [ $kofamscan_used == "true" ]; then
    kofamscan_version=$(exec_annotation -v | cut -f 2 -d " ")
    printf "KOfamScan ${kofamscan_version}\nAramaki, T et al. KofamKOALA: KEGG Ortholog assignment based on profile HMM and adaptive score threshold. Bioinformatics. 2020. doi.org/10.1093/bioinformatics/btz859\n\n" >> ${output_dir}/citations.txt
fi

if [ $pfam_db_used == "true" ]; then
    printf "Pfam database\nMistry J et al. Pfam: the protein families database in 2021. Nucleic Acids Research. 2021. doi.org/10.1093/nar/gkaa913\n\n" >> ${output_dir}/citations.txt
fi

if [ $gtdb_used == "true" ]; then
    printf "Genome Taxonomy Database (GTDB) ${gtdb_version}; ${gtdb_release_date}\nParks DH et al. A complete domain-to-species taxonomy for Bacteria and Archaea. Nat. Biotech. 2020. doi.org/10.1038/s41587-020-0501-8\n\n" >> ${output_dir}/citations.txt
fi

if [ $veryfasttree_used == "true" ]; then
    veryfasttree_version=$(VeryFastTree -h | head -n 1 | cut -f 2 -d " ")
    printf "VeryFastTree v${veryfasttree_version}\nPineiro C et al. VeryFastTree: speeding up the estimation of phylogenies for large alignments through parallelization and vectorization strategies. Bioinformatics. 2020. doi.org/10.1093/bioinformatics/btaa582\n\n" >> ${output_dir}/citations.txt
    fasttree_used="true" # setting so the fasttree citation is included too since this is built off of that
fi

if [ $fasttree_used == "true" ]; then
    if [ $veryfasttree_used == "true" ]; then
        printf "FastTree2 (VeryFastTree, noted above, is an optimized re-implementation of FastTree2, so you should probably cite both even though FastTree2 wasn't directly used here.)\nPrice MN et al. FastTree 2 - approximately maximum-likelihood trees for large alignments. PLoS One. 2010; 5. doi.org/10.1371/journal.pone.0009490\n\n" >> ${output_dir}/citations.txt
    else
        fasttree_version=$(FastTree -expert 2>&1 | head -n 1 | tr -s " " "\t" | cut -f 5)
        printf "FastTree2 v${fasttree_version}\nPrice MN et al. FastTree2 - approximately maximum-likelihood trees for large alignments. PLoS One. 2010; 5. doi.org/10.1371/journal.pone.0009490\n\n" >> ${output_dir}/citations.txt
    fi
fi

if [ $iqtree_used == "true" ]; then
    iqtree_version=$(iqtree -V | head -n 1 | tr -s " " "\t" | cut -f 4)
    printf "IQ-TREE v${iqtree_version}\nNguyen L-T et al. IQ-TREE: a fast and effective stochastic algorithm for estimating maximum likelihood phylogenies. Mol. Biol. Evol. 2015; 32, 268-274. doi.org/10.1093/molbev/msu300\n" >> ${output_dir}/citations.txt
    printf "Kalyaanamoorthy et al. ModelFinder: fast model selection for accurate phylogenetic estimates. Nat. Methods 2017; 14:587-589. doi.org/10.1038/nmeth.4285\n" >> ${output_dir}/citations.txt
    # bootstrap only used if greater than 4 genomes
    if [ $genomes_retained -ge 4 ]; then
        printf "Hoang et al. UFBoot2: Improving the ultrafast bootstrap approximation. Mol. Biol. Evol. 2018; 35:518-522. doi.org/10.1093/molbev/msx281\n\n" >> ${output_dir}/citations.txt
    else
        printf "\n" >> ${output_dir}/citations.txt
    fi

fi

if [ $parallel_used == "true" ]; then
    parallel_version=$(parallel --version | head -n 1 | tr -s " " "\t" | cut -f 3)
    printf "GNU Parallel v${parallel_version}\nTange O. GNU Parallel 2018. doi.org/10.5281/zenodo.1146014\n\n" >> ${output_dir}/citations.txt
fi

if [ $universal_SCGs_used == "true" ]; then
    printf "Universal SCG-set\nHug LA et al. A new view of the tree of life. Nat. Microbiol. 2016; 1, 1-6. doi.org/10.1038/NMICROBIOL.2016.48\n\n" >> ${output_dir}/citations.txt
fi

duration=$SECONDS

printf "\n                                         Total process runtime: $(($duration / 60 / 60)) hours and $((($duration / 60) % 60)) minutes.\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

today=$(date +'%A')

printf "                                                      ${GREEN}Happy $today :)${NC}\n\n" | tee >( sed 's/\x1b\[[0-9;]*m//g' >> ${gtotree_log} )

mv $gtotree_log ${output_dir}/gtotree-runlog.txt
